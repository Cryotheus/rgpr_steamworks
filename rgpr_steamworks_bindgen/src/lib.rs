use std::collections::{HashSet, VecDeque};
use std::io::Write;
use std::path::{Path, PathBuf};
use std::{fs, io};
use syn::{ItemForeignMod, parse_quote};

#[derive(Debug, thiserror::Error)]
pub enum SapiBindgenError {
	#[error("bindgen")]
	Bindgen(#[from] bindgen::BindgenError),

	#[error("io")]
	Io(#[from] io::Error),

	#[error("syn")]
	Syn(#[from] syn::Error),
}

/// Given the path to the steamwork's SDK -
pub fn generate_bindings(headers_dir: impl AsRef<Path>, output_path: impl AsRef<Path>) -> Result<(), SapiBindgenError> {
	let headers_dir = headers_dir.as_ref();
	let output_path = output_path.as_ref();
	let mut output_dir = output_path.to_path_buf();

	output_dir.pop();

	let mut output_file = fs::OpenOptions::new().write(true).create(true).truncate(true).open(output_path)?;

	output_file.lock()?;

	//let temp_name = format!("rgpr_bindgen_temp_{}", process::id());
	//let temp_dir = output_dir.join(&temp_name);
	//let lock_path = output_path.with_file_name(temp_name).with_extension("lock");
	//let lock_file = fs::OpenOptions::new().write(true).create(true).truncate(true).open(lock_path)?;

	//make sure we're the only ones doing bindgen
	//lock_file.lock()?;
	//fs::create_dir(temp_dir)?;

	let bindings_string = run_bindgen(headers_dir);

	//fix bad memory tests on linux for certain interface pointers
	#[cfg(all(target_os = "linux", target_pointer_width = "64"))]
	let bindings_string = replace_ptr_alignments(&bindings_string, HashSet::from(["ISteamParties", "ISteamUGC", "ISteamInventory", "ISteamTimeline", "ISteamVideo"]));

	//TODO: fix mem layout assertions!
	let mut bindings_file = syn::parse_str::<syn::File>(&bindings_string)?; //raw_bindings

	//allow unused_qualifications
	//the fully qualified paths will be used, and that's okay!
	bindings_file.attrs.push(parse_quote! { #![allow(unused_qualifications)] });

	//consolidate consecutive `extern "C" {}` blocks
	let mut previous: Option<&mut ItemForeignMod> = None;
	let mut removal_indices = VecDeque::<usize>::new();

	for (index, item) in bindings_file.items.iter_mut().enumerate() {
		let syn::Item::ForeignMod(foreign_mod) = item else {
			previous = None;

			continue;
		};

		let Some(previous_foreign_mod) = &mut previous else {
			previous = Some(foreign_mod);

			continue;
		};

		removal_indices.push_front(index);
		previous_foreign_mod.items.append(&mut foreign_mod.items);
	}

	//remove the now-empty foreign modules
	for index in removal_indices {
		bindings_file.items.remove(index);
	}

	let bindings_pretty = prettyplease::unparse(&bindings_file);

	output_file.write_all(bindings_pretty.as_bytes())?;
	output_file.flush()?;

	Ok(())
}

/// Returns a `String` of the bindings generated by `bindgen`.
fn run_bindgen(headers_dir: impl Into<PathBuf>) -> String {
	use bindgen::Formatter;

	static VERSION: [u64; 2] = [85, 1];

	let Ok(rust_ver) = bindgen::RustTarget::stable(VERSION[0], VERSION[1]) else {
		panic!("bindgen does not support Rust v{}.{}.0", VERSION[0], VERSION[1]);
	};

	let headers_dir = headers_dir.into();
	let bindgen_dt = bindgen::Builder::default()
		.headers([
			headers_dir.join("steam_api_flat.h").to_string_lossy(),
			headers_dir.join("isteamclient.h").to_string_lossy(),
			headers_dir.join("steamencryptedappticket.h").to_string_lossy(),
			headers_dir.join("isteamappticket.h").to_string_lossy(),
			//its okay to have both the client and gameserver headers mixed
			//as they all will be given different identifiers when bindgen generates
			//
			headers_dir.join("steam_gameserver.h").to_string_lossy(),
		])
		.rust_target(rust_ver)
		.clang_arg("-xc++")
		.clang_arg("-std=c++14")
		.clang_arg(format!("-I{}", headers_dir.display()))
		.default_enum_style(bindgen::EnumVariation::Rust { non_exhaustive: false })
		//we can do this ourselves later
		//bindgen's isnt very good
		.generate_comments(false)
		//for normal global accessors
		.generate_inline_functions(false)
		.formatter(Formatter::None)
		.generate()
		.expect("steamworks bindgen failed");

	bindgen_dt.to_string()
}

fn replace_ptr_alignments(mut input: &str, replacements: HashSet<&str>) -> String {
	let begin_pattern = "[:: std :: mem :: align_of :: < ";
	let end_pattern = " > () - 4usize]";
	let end_replace = " > () - 8usize]";

	let mut string = String::with_capacity(input.len());

	//"[:: std :: mem :: align_of :: < {type_ident} > () - 8usize]"

	while let Some(end_find) = input.find(end_pattern) {
		let before_end = &input[..end_find];
		let used = &input[..(end_find + end_pattern.len())];

		if let Some(begin_find) = before_end.rfind(begin_pattern) {
			let type_ident = &before_end[(begin_find + begin_pattern.len())..];

			if replacements.contains(type_ident) {
				//let to_push = before_end;
				//input = to_push;

				string.push_str(before_end);
				string.push_str(end_replace);

				input = &input[used.len()..];
				
				continue;
			}
		}

		//push what did pass the filter
		input = &input[used.len()..];

		string.push_str(used);
	}

	string.push_str(input);

	//rebuild.

	string
}
